### Project Blueprint & Development Strategy

The development will be broken down into discrete, iterative stages. This approach ensures that we establish a working foundation first and then progressively add complexity, making debugging easier and guaranteeing that each step results in a functional (though incomplete) component.

1.  **Phase 1: Static Structure and Visuals.** The first priority is to correctly render the static elements in 3D space. We will build the complete HTML structure and apply the necessary CSS to position the 7 "arms" and 14 "frames" in their fixed circular arrangement. At the end of this phase, we should see the static, non-interactive barrel carousel.
2.  **Phase 2: Introducing Dynamic State & Basic Interaction.** We will integrate an animation library (Framer Motion is ideal, as suggested) to control the carousel's rotation. We will replace the static rotation with a dynamic `motion` value and implement the core drag-to-rotate functionality.
3.  **Phase 3: Implementing Automated Behavior.** Once user-driven interaction is working, we will add the automatic rotation feature. This includes the logic for the constant 30-second rotation, pausing on user interaction, and resuming after a 5-second delay.
4.  **Phase 4: Adding Responsiveness.** With the core functionality complete, we will implement the responsive logic. A custom hook will detect the viewport size and adjust the carousel's `perspective` and `translateZ` to change the number of visible frames as specified.
5.  **Phase 5: Finalization and Encapsulation.** The last step involves cleaning up the code, ensuring it accepts the image data as a prop, adding type definitions, and writing comments for clarity, resulting in a robust, reusable component.

This iterative process ensures that the most complex part—the 3D geometry—is validated first, followed by layers of interactivity and dynamic behavior.

---

### LLM Prompts for Component Implementation

Below are the series of prompts designed to be fed to a code-generation LLM. Each prompt builds directly on the code generated by the previous one.

---

### Prompt 1: Initial Component & Data Setup ✅ COMPLETED

```text
Create a new Next.js component named `PerspectiveCarousel`. It should be in its own folder, for example, `components/PerspectiveCarousel`.

Inside this folder, create two files:
1.  `index.tsx`: This will contain the React component.
2.  `styles.module.css`: This will be the CSS Module for our component's styles.

Also, create a separate data file at `lib/imageData.ts`. This file should export a constant array named `imageUrls` containing 14 unique placeholder image URLs. You can use a service like `https://picsum.photos/` to generate these, for example: `https://picsum.photos/seed/1/260/370`.

In `index.tsx`, import the `imageUrls` array and the styles. The component should accept a prop `images` (an array of strings) but use the imported `imageUrls` as a default for now. Render a single root `<div>`.
```

---

### Prompt 2: Building the Static DOM Structure ✅ COMPLETED

```text
Based on the previous step, let's build the full static DOM structure inside the `PerspectiveCarousel` component.

Using the `imageUrls` array, map over the data to render the precise nested structure as described in the spec. The hierarchy should be:

- A root `div` with `className={styles.carouselWrapper}`.
- Inside, a `div` with `className={styles.carousel}`.
  - Inside, a `div` with `className={styles.armsContainer}`.
    - This container should hold exactly 7 `div`s, each representing an "arm." Give each arm a base class of `styles.arm`.
    - Each "arm" `div` must contain exactly two "frame" `div`s.
    - Each "frame" `div` should contain an `<img>` tag. The `src` for the images should come from our `imageUrls` array (the first arm gets images 0 and 1, the second gets 2 and 3, and so on). Give each frame a class of `styles.frame`.

Now, add the initial CSS to `styles.module.css` for basic layout and sizing only.

- **`.carouselWrapper`**: Set `height: 240px` and `width: 100%`. Also add `perspective: 500px`.
- **`.carousel`**: Set `width: 100%`, `height: 100%`, `position: relative`, and `transform-style: preserve-3d`.
- **`.armsContainer`**: Center it absolutely within `.carousel`. Set its `transform-style: preserve-3d`.
- **`.arm`**: Position it absolutely. Set `height: 240px`, `width: 1400px`, `display: flex`, `justify-content: space-between`, `align-items: center`, and `transform-style: preserve-3d`.
- **`.frame`**: Set `height: 370px`, `width: 260px`, `position: relative`, and make the `img` inside use `object-fit: cover`. Add `user-select: none` and `touch-action: none` to the `.carouselWrapper`.
```

---

### Prompt 3: Applying Static 3D Transforms ✅ COMPLETED

```text
Now, let's apply the static 3D transforms to position the arms and frames correctly. We will not add any interactivity yet.

In `styles.module.css`, modify the styles to achieve the 3D barrel effect:

1.  **Arms (`.arm`)**: We need to position each of the 7 arms in a circle. Create unique styles for each arm to apply a `rotateY` transform. The angle for each arm will be `(360 / 7) * armIndex`.
    - arm 0: `transform: rotateY(0deg) translateZ(550px);`
    - arm 1: `transform: rotateY(51.42deg) translateZ(550px);`
    - arm 2: `transform: rotateY(102.84deg) translateZ(550px);`
    - ...and so on for all 7 arms.
    The `translateZ` value pushes the arms out from the center to form the carousel's radius. A value around `550px` is a good starting point. You will need to apply these styles dynamically in the component. A good way is to use the `style` prop on the arm elements within the `map` function.

2.  **Frames (`.frame`)**: Within each arm, position the two frames.
    - The first frame in an arm needs `transform: rotateY(90deg) translateZ(-130px)`.
    - The second frame in an arm needs `transform: rotateY(-90deg) translateZ(-130px)`.
    - The `translateZ` here positions the frame along the arm's new Z-axis. `130px` is half the frame's width, placing it perfectly on the edge.

After applying these styles, the carousel should render as a static, 3D cylinder of images. The `perspective` on the wrapper will create the barrel distortion effect.
```

---

### Prompt 4: Integrating Framer Motion for Dynamic Rotation ✅ COMPLETED

```text
Let's refactor the component to use Framer Motion to control the rotation, preparing it for interactivity.

1.  Install Framer Motion: `npm install framer-motion`.
2.  In `index.tsx`, import `motion` from `framer-motion`.
3.  Change the `.carousel` div to be a `motion.div`.
4.  Introduce state to manage the carousel's rotation. Add `const rotateY = useMotionValue(0);` at the top of your component.
5.  Apply this dynamic rotation to the `motion.div` for the `.armsContainer`. Its `style` prop should now include `rotateY`.
6.  To ensure the initial frame is centered, we need to apply an initial rotation. The angle for one segment is `360 / 14`. To center Frame 0 (which is on Arm 0), we don't need any initial rotation. We will set the initial `rotateY` to `0`.

The component should look identical to the previous step, but the rotation is now controlled by a Framer Motion value.
```

---

### Prompt 5: Implementing Drag-to-Rotate Interaction ✅ COMPLETED

```text
Now we will make the carousel interactive by adding drag-to-rotate functionality.

1.  In `PerspectiveCarousel/index.tsx`, we will use Framer Motion's drag capabilities. Add the `drag="x"` prop to the main `motion.div` (`.carouselWrapper` or a new dedicated drag-surface div that covers it).
2.  We need to track the rotation. Let's create a state for the current rotation angle: `const [rotation, setRotation] = useState(0);`.
3.  Use the `onDrag` event handler. The `info.offset.x` value tells us how far the user has dragged. We need to convert this pixel distance into a rotation angle. A sensitivity factor will be useful here; for example, every pixel dragged could equal `-0.1` degrees of rotation.
4.  In the `onDrag` handler, update the `rotateY` motion value by adding the calculated drag rotation to the base `rotation` state: `rotateY.set(rotation + (info.offset.x * -0.1));`.
5.  Use the `onDragEnd` handler to "commit" the rotation. When the drag ends, update the `rotation` state with the final angle: `setRotation(current => current + (info.offset.x * -0.1));`.

Now, the user should be able to drag the carousel left and right to rotate it.
```

---

### Prompt 6: Adding Automatic Rotation and Pausing ✅ COMPLETED

````text
Let's implement the automatic clockwise rotation and the pause/resume logic.

1.  We'll use Framer Motion's `animate` function for a smooth animation. Create a `controls` object using `const controls = useAnimation();`. Link it to the `.armsContainer` motion div via the `animate={controls}` prop.
2.  Create a function `startAutoRotate` that animates the `rotateY` of the `.armsContainer`. The animation should rotate a full `-360` degrees (clockwise) relative to its current position over 30 seconds, with an infinite loop.
    ```javascript
    const startAutoRotate = () => {
      controls.start({
        rotateY: [rotateY.get(), rotateY.get() - 360],
        transition: { duration: 30, ease: 'linear', repeat: Infinity }
      });
    };
    ```
3.  Use a `useEffect` to call `startAutoRotate` when the component mounts.
4.  **Interaction Logic**:
    - When a drag starts (`onDragStart`), stop the animation using `controls.stop()`.
    - When a drag ends (`onDragEnd`), use a `setTimeout` to call `startAutoRotate()` again after 5000ms (5 seconds). You'll need to manage this timer with a `useRef` to clear it if another interaction happens before it fires.

Now the carousel should rotate automatically, pause when dragged, and resume 5 seconds after the drag ends.
````

---

### Prompt 7: Implementing Responsiveness

```text
The final piece of functionality is making the carousel responsive. We need to adjust the view to show approximately 9, 6, or 3 frames based on the screen width. This is best achieved by changing the `translateZ` of the `.armsContainer` and the `perspective` on the wrapper.

1.  Create a custom hook `useResponsiveCarousel.ts`. This hook will use `window.matchMedia` to determine the current viewport size. It should return an object with the appropriate `perspective` and `translateZ` values.
    - **Phone (e.g., `< 768px`):** `{ perspective: '500px', translateZ: '180px' }` (shows ~3 frames)
    - **MacBook (e.g., `768px - 1280px`):** `{ perspective: '500px', translateZ: '350px' }` (shows ~6 frames)
    - **Studio Display (e.g., `> 1280px`):** `{ perspective: '500px', translateZ: '550px' }` (shows ~9 frames)
    The hook should listen for window resize events and update its return value accordingly.

2.  In the `PerspectiveCarousel` component, call this hook: `const { perspective, translateZ } = useResponsiveCarousel();`.

3.  Apply these dynamic values to the styles of the respective elements. The `perspective` value goes on the `.carouselWrapper`, and the `translateZ` must be dynamically applied to the transform of each `.arm` element, in addition to its `rotateY`.

Now, when resizing the browser window, the carousel's depth should change, altering the number of visible frames.
```

---

### Prompt 8: Final Cleanup and Componentization

```text
Let's finalize the `PerspectiveCarousel` component to make it a clean, reusable, and well-documented module.

1.  **Prop Handling**: Modify the component to primarily use the `imageUrls` prop passed into it, instead of the local import. The local import can serve as a fallback or for development.
2.  **Type Safety**: Add TypeScript types for the component's props. Create an interface `PerspectiveCarouselProps` that defines `imageUrls: string[]`. Ensure your component adheres to this. The array should ideally be validated to contain exactly 14 items.
3.  **Code Comments**: Add comments to the more complex parts of the code, especially:
    - The `onDrag` and `onDragEnd` logic.
    - The `useEffect` for auto-rotation and its cleanup.
    - The dynamic application of `rotateY` and `translateZ` transforms.
4.  **Final Review**: Remove any `console.log` statements or unused variables. Ensure the CSS class names are consistent and the file structure is clean.

The final result should be a self-contained component that can be imported and used anywhere in the Next.js application by simply passing it an array of 14 image URLs.
```
